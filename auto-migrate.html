<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      max-width: 1200px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      border-bottom: 3px solid #007bff;
      padding-bottom: 10px;
    }
    #log {
      background: #000;
      color: #0f0;
      padding: 20px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      height: 600px;
      overflow-y: auto;
      margin-top: 20px;
    }
    .progress {
      margin: 20px 0;
      padding: 15px;
      background: #f8f9fa;
      border-left: 4px solid #007bff;
      border-radius: 4px;
    }
    .progress-bar {
      width: 100%;
      height: 30px;
      background: #e9ecef;
      border-radius: 15px;
      overflow: hidden;
      margin-top: 10px;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #007bff, #0056b3);
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 5px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    .danger {
      background: #dc3545;
    }
    .danger:hover {
      background: #c82333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸš€ ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰</h1>
    
    <div style="background: #fff3cd; border: 1px solid #ffc107; padding: 15px; border-radius: 4px; margin-bottom: 20px;">
      <strong>âš ï¸ ê²½ê³ :</strong> ì´ ì‘ì—…ì€ schedules ì»¬ë ‰ì…˜ì„ ìë™ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.<br>
      ëª¨ë“  ë‹¨ê³„ê°€ ìë™ìœ¼ë¡œ ì‹¤í–‰ë˜ë©°, ë¬¸ì œ ë°œìƒ ì‹œ ë¡¤ë°±ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
    </div>

    <div class="progress">
      <div><strong>ì§„í–‰ ìƒí™©</strong></div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%">0%</div>
      </div>
      <div id="currentStep" style="margin-top: 10px; color: #666;">ëŒ€ê¸° ì¤‘...</div>
    </div>

    <button onclick="startMigration()" id="startBtn">ğŸš€ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘</button>
    <button onclick="rollback()" id="rollbackBtn" class="danger" style="display: none;">ğŸ”™ ë¡¤ë°± ì‹¤í–‰</button>

    <div id="log"></div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

  <script>
    // Firebase ì„¤ì •
    const firebaseConfig = {
      apiKey: "AIzaSyCr3Tq2T7oy5rVlK1c33m_G0TlUWv0-g3k",
      authDomain: "abcdc-staff-system.firebaseapp.com",
      projectId: "abcdc-staff-system",
      storageBucket: "abcdc-staff-system.firebasestorage.app",
      messagingSenderId: "442207878284",
      appId: "1:442207878284:web:49b157573851b124d28fa9",
      measurementId: "G-WYPQ3YEJRT"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    let migrationState = {
      completed: false,
      canRollback: false
    };

    // ë¡œê·¸ í•¨ìˆ˜
    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const timestamp = new Date().toLocaleTimeString('ko-KR');
      const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'ğŸ“';
      logDiv.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }

    function updateProgress(percent, stepText) {
      document.getElementById('progressFill').style.width = percent + '%';
      document.getElementById('progressFill').textContent = percent + '%';
      document.getElementById('currentStep').textContent = stepText;
    }

    // ISO 8601 ì£¼ì°¨ ê³„ì‚°
    function getMondayOfWeek(year, weekNum) {
      const jan4 = new Date(year, 0, 4);
      const jan4Day = jan4.getDay() || 7;
      const firstMonday = new Date(jan4);
      firstMonday.setDate(jan4.getDate() - jan4Day + 1);
      
      const targetMonday = new Date(firstMonday);
      targetMonday.setDate(firstMonday.getDate() + (weekNum - 1) * 7);
      
      return targetMonday;
    }

    // ì „ì²´ ë§ˆì´ê·¸ë ˆì´ì…˜ ìë™ ì‹¤í–‰
    async function startMigration() {
      try {
        document.getElementById('startBtn').disabled = true;
        log('========================================');
        log('ğŸš€ ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹œì‘');
        log('========================================\n');

        // ë¡œê·¸ì¸ ìƒíƒœ í™•ì¸
        const user = firebase.auth().currentUser;
        if (!user) {
          log('âŒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤!', 'error');
          log('ê´€ë¦¬ì ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.', 'error');
          log('ë¡œê·¸ì¸ í˜ì´ì§€: https://abcdc-staff-system.web.app/admin-login.html', 'warning');
          updateProgress(0, 'ë¡œê·¸ì¸ í•„ìš”');
          document.getElementById('startBtn').disabled = false;
          return;
        }
        
        log(`í˜„ì¬ ë¡œê·¸ì¸: ${user.email}`);
        
        // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸
        const userDoc = await db.collection('users').doc(user.uid).get();
        if (!userDoc.exists) {
          log('âŒ ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
          updateProgress(0, 'ì‚¬ìš©ì ì •ë³´ ì—†ìŒ');
          document.getElementById('startBtn').disabled = false;
          return;
        }
        
        const userData = userDoc.data();
        log(`ì‚¬ìš©ì ê¶Œí•œ: ${userData.role || 'ê¶Œí•œ ì—†ìŒ'}`);
        
        if (userData.role !== 'admin') {
          log('âŒ ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤!', 'error');
          log(`í˜„ì¬ ê¶Œí•œ: ${userData.role}`, 'error');
          log('ê´€ë¦¬ì ê³„ì •ìœ¼ë¡œ ë‹¤ì‹œ ë¡œê·¸ì¸í•˜ì„¸ìš”.', 'warning');
          updateProgress(0, 'ê´€ë¦¬ì ê¶Œí•œ í•„ìš”');
          document.getElementById('startBtn').disabled = false;
          return;
        }
        
        log('âœ… ê´€ë¦¬ì ê¶Œí•œ í™•ì¸ ì™„ë£Œ\n', 'success');

        // 0ë‹¨ê³„: êµ¬ì¡° í™•ì¸
        updateProgress(0, '0ë‹¨ê³„: í˜„ì¬ ë°ì´í„° êµ¬ì¡° í™•ì¸ ì¤‘...');
        const structureCheck = await checkStructure();
        
        if (!structureCheck.needsMigration) {
          log('âœ… ë§ˆì´ê·¸ë ˆì´ì…˜ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.', 'success');
          if (structureCheck.type === 'daily') {
            log('ì´ë¯¸ ë‚ ì§œë³„ êµ¬ì¡°ë¡œ ë˜ì–´ìˆìŠµë‹ˆë‹¤.', 'success');
          }
          updateProgress(100, 'ì™„ë£Œ - ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆí•„ìš”');
          return;
        }

        // 1ë‹¨ê³„: ë°±ì—…
        updateProgress(20, '1ë‹¨ê³„: ë°ì´í„° ë°±ì—… ì¤‘...');
        await backupData();

        // 2ë‹¨ê³„: ë³€í™˜
        updateProgress(40, '2ë‹¨ê³„: ë°ì´í„° ë³€í™˜ ì¤‘...');
        await migrateData();

        // 3ë‹¨ê³„: ê²€ì¦
        updateProgress(60, '3ë‹¨ê³„: ë°ì´í„° ê²€ì¦ ì¤‘...');
        const validation = await validateData();
        
        if (!validation.isValid) {
          log('âŒ ê²€ì¦ ì‹¤íŒ¨! ì „í™˜ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.', 'error');
          log(`ì›ë³¸: ${validation.originalWorkDays}ê°œ, ë³€í™˜: ${validation.newDocs}ê°œ`, 'error');
          updateProgress(60, 'ê²€ì¦ ì‹¤íŒ¨ - ì „í™˜ ì¤‘ë‹¨');
          document.getElementById('startBtn').disabled = false;
          return;
        }

        // 4ë‹¨ê³„: ì „í™˜
        updateProgress(80, '4ë‹¨ê³„: ì»¬ë ‰ì…˜ ì „í™˜ ì¤‘...');
        log('\nâš ï¸ 5ì´ˆ í›„ í”„ë¡œë•ì…˜ ì „í™˜ì„ ì‹œì‘í•©ë‹ˆë‹¤...', 'warning');
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        await switchCollections();

        // ì™„ë£Œ
        updateProgress(100, 'âœ… ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ!');
        log('\n========================================');
        log('âœ… ëª¨ë“  ë‹¨ê³„ ì™„ë£Œ!', 'success');
        log('========================================\n');
        log('ë‹¤ìŒ ì‘ì—…:');
        log('1. ê´€ë¦¬ì í˜ì´ì§€ì—ì„œ ìŠ¤ì¼€ì¤„ í…Œì´ë¸” í™•ì¸');
        log('2. êµëŒ€ê·¼ë¬´ ìŠ¹ì¸ í…ŒìŠ¤íŠ¸');
        log('3. ì§ì› í˜ì´ì§€ì—ì„œ ë³¸ì¸ ìŠ¤ì¼€ì¤„ í™•ì¸\n');

        migrationState.completed = true;
        migrationState.canRollback = true;
        document.getElementById('rollbackBtn').style.display = 'inline-block';

      } catch (error) {
        log(`\nâŒ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤íŒ¨: ${error.message}`, 'error');
        console.error(error);
        updateProgress(0, 'ì‹¤íŒ¨ - ì¬ì‹œë„ ê°€ëŠ¥');
        document.getElementById('startBtn').disabled = false;
      }
    }

    // 0ë‹¨ê³„: êµ¬ì¡° í™•ì¸
    async function checkStructure() {
      try {
        log('í˜„ì¬ schedules ì»¬ë ‰ì…˜ êµ¬ì¡° í™•ì¸ ì¤‘...\n');

        const snapshot = await db.collection('schedules').limit(10).get();
        
        if (snapshot.empty) {
          log('âš ï¸ schedules ì»¬ë ‰ì…˜ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.', 'warning');
          return { needsMigration: false, type: 'empty' };
        }

        let weeklyCount = 0;
        let dailyCount = 0;

        snapshot.forEach(doc => {
          const data = doc.data();
          const hasDateField = 'date' in data;
          const hasDayFields = 'ì›”' in data || 'í™”' in data;

          if (hasDateField && !hasDayFields) {
            dailyCount++;
          } else if (hasDayFields && !hasDateField) {
            weeklyCount++;
          }
        });

        log(`ìƒ˜í”Œ ë¶„ì„: ì£¼ì°¨ë³„ ${weeklyCount}ê°œ, ë‚ ì§œë³„ ${dailyCount}ê°œ\n`);

        if (weeklyCount > 0 && dailyCount === 0) {
          log('âœ… ì£¼ì°¨ë³„ êµ¬ì¡° ê°ì§€ - ë§ˆì´ê·¸ë ˆì´ì…˜ í•„ìš”', 'success');
          return { needsMigration: true, type: 'weekly' };
        } else if (dailyCount > 0 && weeklyCount === 0) {
          log('âœ… ì´ë¯¸ ë‚ ì§œë³„ êµ¬ì¡°ì…ë‹ˆë‹¤', 'success');
          return { needsMigration: false, type: 'daily' };
        } else {
          log('âš ï¸ í˜¼í•© êµ¬ì¡° ê°ì§€', 'warning');
          return { needsMigration: false, type: 'mixed' };
        }

      } catch (error) {
        log(`êµ¬ì¡° í™•ì¸ ì‹¤íŒ¨: ${error.message}`, 'error');
        throw error;
      }
    }

    // 1ë‹¨ê³„: ë°±ì—…
    async function backupData() {
      try {
        log('========================================');
        log('1ë‹¨ê³„: ë°±ì—… ì‹œì‘');
        log('========================================\n');

        // ê¸°ì¡´ ë°±ì—… ì‚­ì œ
        const existingBackup = await db.collection('schedules_backup').get();
        if (!existingBackup.empty) {
          let batch = db.batch();
          let count = 0;
          existingBackup.forEach(doc => {
            batch.delete(doc.ref);
            count++;
          });
          await batch.commit();
          log(`ê¸°ì¡´ ë°±ì—… ${count}ê°œ ì‚­ì œ`);
        }

        const snapshot = await db.collection('schedules').get();
        log(`ì´ ${snapshot.size}ê°œ ë¬¸ì„œ ë°±ì—… ì‹œì‘`);

        let batch = db.batch();
        let count = 0;

        for (const doc of snapshot.docs) {
          const backupRef = db.collection('schedules_backup').doc(doc.id);
          batch.set(backupRef, doc.data());
          count++;

          if (count % 500 === 0) {
            await batch.commit();
            log(`${count}ê°œ ë°±ì—… ì™„ë£Œ...`);
            batch = db.batch();
          }
        }

        if (count % 500 !== 0) {
          await batch.commit();
        }

        log(`âœ… ë°±ì—… ì™„ë£Œ: ${count}ê°œ ë¬¸ì„œ\n`, 'success');

      } catch (error) {
        log(`ë°±ì—… ì‹¤íŒ¨: ${error.message}`, 'error');
        throw error;
      }
    }

    // 2ë‹¨ê³„: ë³€í™˜
    async function migrateData() {
      try {
        log('========================================');
        log('2ë‹¨ê³„: ë°ì´í„° ë³€í™˜');
        log('========================================\n');

        // ê¸°ì¡´ schedules_new ì‚­ì œ
        const existingNew = await db.collection('schedules_new').get();
        if (!existingNew.empty) {
          let batch = db.batch();
          let count = 0;
          existingNew.forEach(doc => {
            batch.delete(doc.ref);
            count++;
          });
          await batch.commit();
          log(`ê¸°ì¡´ schedules_new ${count}ê°œ ì‚­ì œ`);
        }

        const snapshot = await db.collection('schedules').get();
        log(`ì´ ${snapshot.size}ê°œ ì£¼ì°¨ ë¬¸ì„œ ë³€í™˜ ì‹œì‘\n`);

        const days = ['ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† ', 'ì¼'];
        let totalNewDocs = 0;
        let batchCount = 0;
        let batch = db.batch();
        let errors = [];

        for (const doc of snapshot.docs) {
          const data = doc.data();
          const docId = doc.id;

          // ë¬¸ì„œ ID íŒŒì‹±
          const parts = docId.split('_');
          if (parts.length < 2) {
            errors.push(docId);
            continue;
          }

          const userId = parts[0];
          const weekInfo = parts[1];
          const [year, weekNum] = weekInfo.split('-').map(Number);

          if (isNaN(year) || isNaN(weekNum)) {
            errors.push(docId);
            continue;
          }

          const mondayDate = getMondayOfWeek(year, weekNum);

          days.forEach((day, index) => {
            const dayData = data[day];

            if (dayData && dayData.isWorkDay) {
              const workDate = new Date(mondayDate);
              workDate.setDate(workDate.getDate() + index);
              const dateStr = workDate.toISOString().split('T')[0];

              const newDoc = {
                userId: userId,
                userName: data.userName || '',
                store: data.store || '',
                date: dateStr,
                startTime: dayData.startTime || '',
                endTime: dayData.endTime || '',
                hours: dayData.hours || 0,
                isShiftReplacement: false,
                shiftRequestId: null,
                originalRequesterId: null,
                originalRequesterName: null,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                migratedFrom: docId,
                migratedAt: firebase.firestore.FieldValue.serverTimestamp()
              };

              const newRef = db.collection('schedules_new').doc();
              batch.set(newRef, newDoc);
              totalNewDocs++;
              batchCount++;

              if (batchCount >= 500) {
                log(`${totalNewDocs}ê°œ ë³€í™˜ ì™„ë£Œ...`);
                batch.commit();
                batch = db.batch();
                batchCount = 0;
              }
            }
          });
        }

        if (batchCount > 0) {
          await batch.commit();
        }

        log(`âœ… ë³€í™˜ ì™„ë£Œ: ${totalNewDocs}ê°œ ê·¼ë¬´ ë¬¸ì„œ ìƒì„±\n`, 'success');
        
        if (errors.length > 0) {
          log(`âš ï¸ ê²½ê³ : ${errors.length}ê°œ ë¬¸ì„œ ë³€í™˜ ì‹¤íŒ¨`, 'warning');
        }

      } catch (error) {
        log(`ë³€í™˜ ì‹¤íŒ¨: ${error.message}`, 'error');
        throw error;
      }
    }

    // 3ë‹¨ê³„: ê²€ì¦
    async function validateData() {
      try {
        log('========================================');
        log('3ë‹¨ê³„: ë°ì´í„° ê²€ì¦');
        log('========================================\n');

        const originalSnapshot = await db.collection('schedules').get();
        const days = ['ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† ', 'ì¼'];
        
        let originalWorkDays = 0;
        originalSnapshot.forEach(doc => {
          const data = doc.data();
          days.forEach(day => {
            if (data[day] && data[day].isWorkDay) {
              originalWorkDays++;
            }
          });
        });

        const newSnapshot = await db.collection('schedules_new').get();
        const newDocs = newSnapshot.size;

        log(`ì›ë³¸ ê·¼ë¬´ì¼: ${originalWorkDays}ê°œ`);
        log(`ë³€í™˜ ë¬¸ì„œ: ${newDocs}ê°œ`);

        const isValid = originalWorkDays === newDocs;
        
        if (isValid) {
          log(`âœ… ê²€ì¦ ì„±ê³µ!\n`, 'success');
        } else {
          log(`âŒ ê²€ì¦ ì‹¤íŒ¨! ì°¨ì´: ${Math.abs(originalWorkDays - newDocs)}ê°œ\n`, 'error');
        }

        return { isValid, originalWorkDays, newDocs };

      } catch (error) {
        log(`ê²€ì¦ ì‹¤íŒ¨: ${error.message}`, 'error');
        throw error;
      }
    }

    // 4ë‹¨ê³„: ì „í™˜
    async function switchCollections() {
      try {
        log('========================================');
        log('4ë‹¨ê³„: ì»¬ë ‰ì…˜ ì „í™˜');
        log('========================================\n');

        // schedules â†’ schedules_old
        log('schedules â†’ schedules_old ì´ë™ ì¤‘...');
        const schedulesSnapshot = await db.collection('schedules').get();
        let batch = db.batch();
        let count = 0;

        for (const doc of schedulesSnapshot.docs) {
          const oldRef = db.collection('schedules_old').doc(doc.id);
          batch.set(oldRef, doc.data());
          batch.delete(doc.ref);
          count++;

          if (count % 500 === 0) {
            await batch.commit();
            log(`  ${count}ê°œ ì´ë™...`);
            batch = db.batch();
          }
        }

        if (count % 500 !== 0) {
          await batch.commit();
        }
        log(`âœ… schedules_old: ${count}ê°œ`, 'success');

        // schedules_new â†’ schedules
        log('\nschedules_new â†’ schedules ì´ë™ ì¤‘...');
        const newSnapshot = await db.collection('schedules_new').get();
        batch = db.batch();
        count = 0;

        for (const doc of newSnapshot.docs) {
          const scheduleRef = db.collection('schedules').doc(doc.id);
          batch.set(scheduleRef, doc.data());
          batch.delete(doc.ref);
          count++;

          if (count % 500 === 0) {
            await batch.commit();
            log(`  ${count}ê°œ ì´ë™...`);
            batch = db.batch();
          }
        }

        if (count % 500 !== 0) {
          await batch.commit();
        }
        log(`âœ… schedules: ${count}ê°œ (í™œì„±)\n`, 'success');

      } catch (error) {
        log(`ì „í™˜ ì‹¤íŒ¨: ${error.message}`, 'error');
        throw error;
      }
    }

    // ë¡¤ë°±
    async function rollback() {
      if (!confirm('ì •ë§ë¡œ ë¡¤ë°±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nschedules_oldë¥¼ schedulesë¡œ ë³µì›í•©ë‹ˆë‹¤.')) {
        return;
      }

      try {
        document.getElementById('rollbackBtn').disabled = true;
        log('\n========================================');
        log('ğŸ”™ ë¡¤ë°± ì‹œì‘');
        log('========================================\n');

        // schedules ì‚­ì œ
        log('í˜„ì¬ schedules ì‚­ì œ ì¤‘...');
        const currentSchedules = await db.collection('schedules').get();
        let batch = db.batch();
        let count = 0;

        currentSchedules.forEach(doc => {
          batch.delete(doc.ref);
          count++;
        });
        await batch.commit();
        log(`${count}ê°œ ì‚­ì œ ì™„ë£Œ`);

        // schedules_old â†’ schedules
        log('\nschedules_old â†’ schedules ë³µì› ì¤‘...');
        const oldSchedules = await db.collection('schedules_old').get();
        batch = db.batch();
        count = 0;

        for (const doc of oldSchedules.docs) {
          const ref = db.collection('schedules').doc(doc.id);
          batch.set(ref, doc.data());
          count++;

          if (count % 500 === 0) {
            await batch.commit();
            batch = db.batch();
          }
        }

        if (count % 500 !== 0) {
          await batch.commit();
        }

        log(`âœ… ë¡¤ë°± ì™„ë£Œ: ${count}ê°œ ë¬¸ì„œ ë³µì›\n`, 'success');
        document.getElementById('rollbackBtn').style.display = 'none';

      } catch (error) {
        log(`ë¡¤ë°± ì‹¤íŒ¨: ${error.message}`, 'error');
        document.getElementById('rollbackBtn').disabled = false;
      }
    }
  </script>
</body>
</html>
